"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7177],{4530:(e,n,t)=>{t.r(n),t.d(n,{data:()=>o});const o={key:"v-622fca5d",path:"/spec/v0.6/protocol/connectivity.html",title:"Connectivity",lang:"en",frontmatter:{},excerpt:"",headers:[{level:2,title:"Network Topology",slug:"network-topology",children:[]},{level:2,title:"Protocol Stack",slug:"protocol-stack",children:[]},{level:2,title:"Communication Patterns",slug:"communication-patterns",children:[{level:3,title:"Request-response",slug:"request-response",children:[]},{level:3,title:"Publish-subscribe",slug:"publish-subscribe",children:[]},{level:3,title:"Sync and async communication",slug:"sync-and-async-communication",children:[]}]}],filePathRelative:"spec/v0.6/protocol/connectivity.md",git:{updatedTime:1707227927e3}}},1488:(e,n,t)=>{t.r(n),t.d(n,{default:()=>Q});var o=t(6252),a=t(4179);const s=(0,o._)("h1",{id:"connectivity",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#connectivity","aria-hidden":"true"},"#"),(0,o.Uk)(" Connectivity")],-1),r=(0,o._)("h2",{id:"network-topology",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#network-topology","aria-hidden":"true"},"#"),(0,o.Uk)(" Network Topology")],-1),i=(0,o._)("p",null,"ThingSet uses a tree topology for communication between applications, gateways and nodes.",-1),l=(0,o._)("p",null,[(0,o.Uk)("A ThingSet "),(0,o._)("strong",null,"node"),(0,o.Uk)(" is an entity with a globally unique ID ("),(0,o._)("code",null,"pNodeID"),(0,o.Uk)(" in the data structure). A physical "),(0,o._)("strong",null,"device"),(0,o.Uk)(" may contain one or more ThingSet nodes.")],-1),c=(0,o._)("p",null,[(0,o.Uk)("An "),(0,o._)("strong",null,"application"),(0,o.Uk)(" needs to establish a "),(0,o._)("strong",null,"communication channel"),(0,o.Uk)(" to the node in order to exchange ThingSet messages. This channel may be established directly with the node or accross one or multiple gateways. Nodes can also autonomously establish synchronous or asynchronous communication channels with a cloud backend, which can afterwards be used by applications or for internal services in a backend.")],-1),d=(0,o._)("p",null,[(0,o.Uk)("A "),(0,o._)("strong",null,"gateway"),(0,o.Uk)(" translates between nodes and an application or cloud backend. It forwards data to exactly one upstream connection. Gateways may also be used to translate foreign protocols like ModBus to ThingSet.")],-1),u=(0,o._)("p",null,[(0,o.Uk)("Data from an application towards the ThingSet node is called "),(0,o._)("strong",null,"downlink data"),(0,o.Uk)(". Data from nodes towards applications or gateways is called "),(0,o._)("strong",null,"uplink data"),(0,o.Uk)(".")],-1),h=(0,o._)("p",null,"The following picture gives an overview of the different possible connections used for ThingSet with some protocols as an example.",-1),p=(0,o._)("p",null,[(0,o._)("img",{src:a,alt:"ThingSet Network Topology"})],-1),g=(0,o._)("h2",{id:"protocol-stack",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#protocol-stack","aria-hidden":"true"},"#"),(0,o.Uk)(" Protocol Stack")],-1),m=(0,o.Uk)("As an application layer protocol, ThingSet protocol is located in the higher layers (5 to 7) of the "),y={href:"https://en.wikipedia.org/wiki/OSI_model",target:"_blank",rel:"noopener noreferrer"},b=(0,o.Uk)("OSI (Open Systems Interconnection) model"),f=(0,o.Uk)(". The payload data is independent of the underlying lower layer protocol or interface such as CAN, USB, Bluetooth, UART (serial) or IP-based protocols."),_=(0,o._)("p",null,"The underlying layers have to ensure encryption, reliable transfer, de-duplication, correct packet order (if messages are packetized) and error-checking of the transferred data.",-1),k=(0,o.Uk)("A major feature of the ThingSet protocol is a seamless integration with other application layer protocols such as "),w={href:"https://tools.ietf.org/html/rfc7252",target:"_blank",rel:"noopener noreferrer"},v=(0,o.Uk)("CoAP"),U=(0,o.Uk)(" and MQTT. See the Mappings section for details."),T=(0,o._)("h2",{id:"communication-patterns",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#communication-patterns","aria-hidden":"true"},"#"),(0,o.Uk)(" Communication Patterns")],-1),S=(0,o._)("p",null,"ThingSet defines four types of messages (requests, responses, desires and reports) which can be used in a synchronous or asynchronous fashion.",-1),q=(0,o._)("h3",{id:"request-response",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#request-response","aria-hidden":"true"},"#"),(0,o.Uk)(" Request-response")],-1),A=(0,o._)("p",null,[(0,o.Uk)("A "),(0,o._)("strong",null,"request"),(0,o.Uk)(" is sent from a client to a single ThingSet node (acting as a server). The node is expected to answer with a "),(0,o._)("strong",null,"response"),(0,o.Uk)(" containing a status code and optional payload.")],-1),x=(0,o._)("p",null,"The client would usually be a display, a mobile phone application or a gateway.",-1),I=(0,o._)("p",null,"A connection can be established either directly (e.g. serial interface, USB, Bluetooth) or via a network or bus with several nodes attached (e.g. CAN, Ethernet, WiFi, LoRa). In case of a network, each device has to be uniquely addressable by the lower-layer protocol.",-1),D=(0,o._)("p",null,"Only a single request can be processed by a node at once. If multiple applications can access a node through a server backend, it must ensure that a response was received before another request is sent to the same node. This avoids transferring a unique message ID to match request with response.",-1),P=(0,o._)("h3",{id:"publish-subscribe",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#publish-subscribe","aria-hidden":"true"},"#"),(0,o.Uk)(" Publish-subscribe")],-1),C=(0,o._)("p",null,[(0,o.Uk)("Data which is not intended for a specific client or which is sent out regularly (e.g. monitoring data to be stored in a database) can be exchanged using a publish-subscribe messaging pattern to increase efficiency and avoid polling. Published messages are called "),(0,o._)("strong",null,"reports"),(0,o.Uk)(". Reports are not confirmed by a receving node and may be broadcast through the network such that any interested node can receive it (subscribe).")],-1),R=(0,o._)("p",null,[(0,o.Uk)("A "),(0,o._)("strong",null,"desire"),(0,o.Uk)(" is a message that is sent to a node without expecting a response or confirmation. It is considered a proposal to update the values as stated in the message. If all or some of the requested changes are invalid, they are silently ignored, as it is not possible to respond to a desire.")],-1),M=(0,o._)("p",null,"Desires can be used to establish control loops for machine-to-machine (M2M) communication by converting reports from one node into a desire sent to another node. In addition to that, desires are useful for asynchronous communication, where an application stores desired changes to the data in the backend and the message is delivered to the device once it connects to the backend again.",-1),N=(0,o._)("h3",{id:"sync-and-async-communication",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#sync-and-async-communication","aria-hidden":"true"},"#"),(0,o.Uk)(" Sync and async communication")],-1),B=(0,o._)("p",null,"The different messaging patterns request-response and publish-subscribe make the ThingSet protocol suitable for both synchronous and asynchronous communication.",-1),O=(0,o._)("p",null,"Synchronous communication means that an application has a live connection (direct or through gateways) to the device, so that it can send a request and receive a response immediately.",-1),W=(0,o._)("p",null,"Asynchronous communication is more suitable for devices which don't have a continuous connection, e.g. because of unreliable networks or for power saving reasons. For asynchronous communication, messages are stored (e.g. in a cloud backend) and retrieved later upon connection of the device.",-1),F=(0,o._)("p",null,"All four message types may be used for synchronous and asynchronous communication. However, applications with asynchronous communication should preferably use desires and reports.",-1),H=(0,o._)("table",null,[(0,o._)("thead",null,[(0,o._)("tr",null,[(0,o._)("th",null,"Message type"),(0,o._)("th",null,"Sync"),(0,o._)("th",null,"Async")])]),(0,o._)("tbody",null,[(0,o._)("tr",null,[(0,o._)("td",null,"Request"),(0,o._)("td",null,"yes"),(0,o._)("td",null,"with workarounds")]),(0,o._)("tr",null,[(0,o._)("td",null,"Response"),(0,o._)("td",null,"yes"),(0,o._)("td",null,"with workarounds")]),(0,o._)("tr",null,[(0,o._)("td",null,"Desire"),(0,o._)("td",null,"yes (requests preferred)"),(0,o._)("td",null,"yes")]),(0,o._)("tr",null,[(0,o._)("td",null,"Report"),(0,o._)("td",null,"yes"),(0,o._)("td",null,"yes")])])],-1),L=(0,o._)("p",null,"An example for the workarounds to communicate with request-response messaging pattern asynchronously is the MQTT mapping for ThingSet, where requests get an ID via the topic they are published to and responses use the same ID in their topic for matching request with response.",-1),Q={render:function(e,n){const t=(0,o.up)("OutboundLink");return(0,o.wg)(),(0,o.iD)(o.HY,null,[s,r,i,l,c,d,u,h,p,g,(0,o._)("p",null,[m,(0,o._)("a",y,[b,(0,o.Wm)(t)]),f]),_,(0,o._)("p",null,[k,(0,o._)("a",w,[v,(0,o.Wm)(t)]),U]),T,S,q,A,x,I,D,P,C,R,M,N,B,O,W,F,H,L],64)}}},4179:(e,n,t)=>{e.exports=t.p+"assets/img/thingset-network-topology.2e830b78.svg"}}]);
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4372],{8727:(e,t,a)=>{a.r(t),a.d(t,{data:()=>o});const o={key:"v-572e9fe0",path:"/spec/v0.5/existing_solutions.html",title:"Existing Solutions",lang:"en",frontmatter:{},excerpt:"",headers:[{level:2,title:"Protocols",slug:"protocols",children:[{level:3,title:"Modbus",slug:"modbus",children:[]},{level:3,title:"Firmata",slug:"firmata",children:[]},{level:3,title:"CANopen and EnergyBus",slug:"canopen-and-energybus",children:[]},{level:3,title:"SAE J1939 / RV-C / NMEA2000 / ISOBUS",slug:"sae-j1939-rv-c-nmea2000-isobus",children:[]},{level:3,title:"XCP (Universal Measurement and Calibration Protocol)",slug:"xcp-universal-measurement-and-calibration-protocol",children:[]},{level:3,title:"UAVCAN",slug:"uavcan",children:[]}]},{level:2,title:"Open Connectivity Foundation",slug:"open-connectivity-foundation",children:[]},{level:2,title:"LwM2M",slug:"lwm2m",children:[]},{level:2,title:"Conclusion",slug:"conclusion",children:[]},{level:2,title:"GOOOSE",slug:"gooose",children:[]},{level:2,title:"Zenoh",slug:"zenoh",children:[]},{level:2,title:"Golioth",slug:"golioth",children:[]}],filePathRelative:"spec/v0.5/existing_solutions.md",git:{updatedTime:1642774965e3}}},2985:(e,t,a)=>{a.r(t),a.d(t,{default:()=>m});var o=a(6252);const i=(0,o.uE)('<h1 id="existing-solutions" tabindex="-1"><a class="header-anchor" href="#existing-solutions" aria-hidden="true">#</a> Existing Solutions</h1><p>In order to not re-invent the wheel, existing standards were investigated prior to the development of the ThingSet specification.</p><p>This chapter gives an overview about the advantages and disadvantages of existing solutions. If you just want to know how ThingSet works, you can move on to the next chapter.</p><p>As the ThingSet protocol was originally developed for energy management based on CAN communication, below analysis covers this aspect in more detail.</p><h2 id="protocols" tabindex="-1"><a class="header-anchor" href="#protocols" aria-hidden="true">#</a> Protocols</h2><h3 id="modbus" tabindex="-1"><a class="header-anchor" href="#modbus" aria-hidden="true">#</a> Modbus</h3><p>Modbus RTU and Modbus TCP are quite old, quasi-standard protocols to read and write registers of a device. Modbus requires knowledge of the accessible register addresses and the data format. A method to discover available settings and measurement values is not possible, so it does not fulfill the requirement to be self-describing.</p><h3 id="firmata" tabindex="-1"><a class="header-anchor" href="#firmata" aria-hidden="true">#</a> Firmata</h3>',8),n=(0,o.Uk)("In the Arduino community, a protocol called "),r={href:"http://firmata.org/wiki/Main_Page",target:"_blank",rel:"noopener noreferrer"},s=(0,o.Uk)("Firmata"),l=(0,o.Uk)(" is very popular to control Arduino devices directly via the serial interface. The protocol based on the MIDI protocol and very compact. However, the approach is very Arduino-specific and targets to remote-control as many Arduino features as possible. ThingSet aims to be a more general purpose solution."),d=(0,o.uE)('<h3 id="canopen-and-energybus" tabindex="-1"><a class="header-anchor" href="#canopen-and-energybus" aria-hidden="true">#</a> CANopen and EnergyBus</h3><p>CANopen is developed by CAN in Automation (CiA). This high level protocol uses CAN as physical layer and adds profile specifications, standardized communication protocol and advanced error handling to the core functionality of CAN. Despite the word &quot;open&quot; in the name, only the basic device profile specifications are open accessible. A paid CiA membership is necessary to access all specifications. Unfortunately, the EnergyBus profiles (CiA 454) for a CAN based energy management system are not provided with free access.</p><p>CiA DS301 specifies the basic communication functionalities of the CANopen application layer.</p><p>Every device (called CANopen node) must have an object dictionary (OD). This is a large table stored in the node which contains all kinds of data, including device parameters, measurement or control data. In addition to that, it stores also data necessary for communication e.g. which datatypes are used or how a message can be transported (broadcast, handshake, ..).</p><p>There are two different types of telegrams:</p><ul><li><p>Service Data Objects (SDOs): These are only used to access the OD. When a device receives an SDO it changes the values of parameters or other OD table entries. The communication is based on a Client/Server relationship. A client initiates an SDO communication, the server then changes its OD according to the client&#39;s instruction and sends a response. The client is typically a master device or an operator who supervises and configures the entire network.</p></li><li><p>Process Data Objects (PDOs): The majority of messages in the bus contain process information like measurement data, control data, status data, etc. The data is read from the OD and transmitted as a PDO, which is basically a pure CAN telegram without protocol overhead. The CAN-identifier of a PDO telegram does not only contain the node-ID of a device (like this is the case in &quot;pure CAN&quot;) but also what kind of content is delivered by the telegram.</p></li></ul><p>The PDO telegrams are not predefined, but they are configured separately for each network. For each device, four Receive-PDOs (RPDOs) and four Transmit-PDOs (TPDOs) can be defined. For example, the actual current of the battery could be sent as a TPDO by the battery management system and an received as RPDO in a charge controller.</p><p>The connection channels between different devices for PDO exchange are defined using a PDO mapping procedure. This has the advantage that the process data exchange between different devices can be very flexible. However, it makes an initial network setup necessary. If a device is added to the network, it has to be shut down, some PDO mappings have to be defined and afterwards the network is put into operation mode again. This contradicts to the requirement of a plug-and-play capable energy system.</p><p>An intelligent master device implementing the network management (NMT) features could be used instead of manual configuration. But also a master device is not beneficial for a distributed, fail-safe energy system.</p><p>Summary of issues:</p><ul><li>Pre-defined frame layout defined in not completely open specification</li><li>Complicated network setup (normally done using proprietary tools)</li><li>Not intended for master-less operation</li><li>Only 4 RPDOs and TPDOs possible per node ID for control functions</li></ul><h3 id="sae-j1939-rv-c-nmea2000-isobus" tabindex="-1"><a class="header-anchor" href="#sae-j1939-rv-c-nmea2000-isobus" aria-hidden="true">#</a> SAE J1939 / RV-C / NMEA2000 / ISOBUS</h3><p>The collection of SAE J1939 standards describe a well-established CAN application layer protocol. Several other protocols like RV-C (recreational vehicles), NMEA2000 (marine applications) and ISOBUS (agriculture machines) are based on SAE J1939.</p><p>Unfortunately, all SAE J1939 based standards (including the base standard itself) are proprietary and not puplic. Only RV-C is available for download.</p><p>SAE J1939 uses only the extended format CAN id with 29 bits and encodes message priority, source ID, destination ID and the type of message (Parameter Group Number, PGN) inside the CAN ID.</p><p>In general, SAE J1939 is based on fixed (specified) layout of the data fields in the CAN frame, depending on the PGN.</p><p>In addition, the protocol is not designed for configuration of parameters. Writing parameters to a device can be achieved only by specifying special PGNs. In contrast to CANopen, parameters cannot be read or written by default.</p><h3 id="xcp-universal-measurement-and-calibration-protocol" tabindex="-1"><a class="header-anchor" href="#xcp-universal-measurement-and-calibration-protocol" aria-hidden="true">#</a> XCP (Universal Measurement and Calibration Protocol)</h3><p>XCP is an established protocol for ECU (Engine Control Unit) development in the automotive industry. It is not limited to CAN as a low level interface, but CAN is probably the most commonly used lower layer.</p><p>Measurement data and calibration parameters are accessed directly via registers in the microcontroller. Thus, the register values and description has to be generated during linking of the binary code. The register description is typically saved in a .A2L file.</p><p>For an agile open source based development, the toolchain for generating the A2L file is considered too complicated. In addition to that, tools for XCP and A2L are mostly proprietary and expensive.</p><p>XCP is also not useable for a master-less control of devices in a system, as this was not a purpose of the protocol.</p><p>However, XCP offers a well-suited way for firmware upgrades of devices. This feature might be adapted in a future version of this specification.</p><h3 id="uavcan" tabindex="-1"><a class="header-anchor" href="#uavcan" aria-hidden="true">#</a> UAVCAN</h3>',24),c={href:"http://uavcan.org/",target:"_blank",rel:"noopener noreferrer"},p=(0,o.Uk)("UAVCAN"),h=(0,o.Uk)(" is a modern and lightweight protocol based on CAN, also targeting a master-less network. Main applications include aerospace and robotic applications."),u=(0,o.uE)('<p>The protocol is fully open, well-designed and easy to be implemented. However, it also uses pre-defined messages for the communication between devices.</p><p>The node ID assignment process is more complicated compared to SAE J1939.</p><p>Some aspects of the UAVCAN protocol might be adapted in the CAN lower layer of this specification.</p><h2 id="open-connectivity-foundation" tabindex="-1"><a class="header-anchor" href="#open-connectivity-foundation" aria-hidden="true">#</a> Open Connectivity Foundation</h2><p>https://openconnectivity.org/</p><p>Clearly has not been written by engineers or natural scientists, but software people.</p><p>Not useful for energy management tasks at all.</p><p>https://oneiota.org/revisions/6174</p><p>A circuit breaker detects <em>power</em> or <em>current</em> overload, but not energy!</p><p>https://oneiota.org/revisions/6138</p><p>Air flow speed without any unit.</p><p>https://oneiota.org/revisions/6148</p><p>Battery without current and voltage measurement</p><p>Using C (Coulomb) as a unit for temperature.</p><p>A timestamp is defined in every single resource, instead of making it part of the overall spec.</p><p>Example for battery:</p><div class="language-text ext-text"><pre class="language-text"><code>        &quot;capacity&quot;: {\n          &quot;description&quot;: &quot;The total capacity in Amp-hours (Ah).&quot;,\n          &quot;readOnly&quot;: true,\n          &quot;type&quot;: &quot;number&quot;\n        },\n</code></pre></div><p>Equivalent in ThingSet:</p><div class="language-text ext-text"><pre class="language-text"><code>\t&quot;Bat_Ah&quot;:50\n</code></pre></div><h2 id="lwm2m" tabindex="-1"><a class="header-anchor" href="#lwm2m" aria-hidden="true">#</a> LwM2M</h2><p>Also based on CoAP</p><p>Registry:</p><p>http://www.openmobilealliance.org/wp/OMNA/LwM2M/LwM2MRegistry.html</p><p>https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod/3411.xml</p><p>No battery current (but at least battery voltage existing)</p><p>https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod/version_history/3303-1_0.xml</p><p>Crazy amount of description just for a temperature value.</p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h2><p>It&#39;s not possible to think of any possible metrics of a device when writing a specification. Changing specifications is a too slow process.</p><p>Every attempt to create a database of devices and all useful properties will fail!</p><p>Solution: More flexible data model needed that can be discovered from the device instead of the specification.</p><h2 id="gooose" tabindex="-1"><a class="header-anchor" href="#gooose" aria-hidden="true">#</a> GOOOSE</h2><p>IEC 61850</p><h2 id="zenoh" tabindex="-1"><a class="header-anchor" href="#zenoh" aria-hidden="true">#</a> Zenoh</h2><h2 id="golioth" tabindex="-1"><a class="header-anchor" href="#golioth" aria-hidden="true">#</a> Golioth</h2>',35),m={render:function(e,t){const a=(0,o.up)("OutboundLink");return(0,o.wg)(),(0,o.iD)(o.HY,null,[i,(0,o._)("p",null,[n,(0,o._)("a",r,[s,(0,o.Wm)(a)]),l]),d,(0,o._)("p",null,[(0,o._)("a",c,[p,(0,o.Wm)(a)]),h]),u],64)}}}}]);
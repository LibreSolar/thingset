"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2287],{2556:(e,t,a)=>{a.r(t),a.d(t,{data:()=>n});const n={key:"v-96638ac0",path:"/spec/v0.5/tools_can.html",title:"CAN bus",lang:"en",frontmatter:{},excerpt:"",headers:[{level:2,title:"Linux",slug:"linux",children:[{level:3,title:"CAN interface setup",slug:"can-interface-setup",children:[]},{level:3,title:"ISO-TP tools",slug:"iso-tp-tools",children:[]}]}],filePathRelative:"spec/v0.5/tools_can.md",git:{updatedTime:170759614e4}}},2368:(e,t,a)=>{a.r(t),a.d(t,{default:()=>l});var n=a(6252);const s=(0,n.uE)('<h1 id="can-bus" tabindex="-1"><a class="header-anchor" href="#can-bus" aria-hidden="true">#</a> CAN bus</h1><h2 id="linux" tabindex="-1"><a class="header-anchor" href="#linux" aria-hidden="true">#</a> Linux</h2><h3 id="can-interface-setup" tabindex="-1"><a class="header-anchor" href="#can-interface-setup" aria-hidden="true">#</a> CAN interface setup</h3><p>There are different USB to CAN dongles available on the market, which usually support communicating with the Linux Kernel via a serial interface.</p><p>The following command creates a <code>can0</code> interface from a dongle attached to <code>/dev/ttyUSB0</code>:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo slcan_attach /dev/ttyUSB0 -w\n</code></pre></div><p>Afterwards, the interface has to be configured and started. Here we are setting the bit rate to 500 kbit/s:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link set can0 type can bitrate 500000 restart-ms 500\nsudo ip link set can0 up\n</code></pre></div><p>If you want to see also your own messages, loopback mode has to be enabled before setting the interface up:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link set can0 type can loopback on\n</code></pre></div><p>Now, <code>candump</code> can be used to read all data available on the bus:</p><div class="language-text ext-text"><pre class="language-text"><code>candump can0\n</code></pre></div><p>Instead of an actual CAN device, also a virtual CAN device can be used on the Linux host:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link add dev vcan0 type vcan\nsudo ip link set up vcan0\n</code></pre></div><h3 id="iso-tp-tools" tabindex="-1"><a class="header-anchor" href="#iso-tp-tools" aria-hidden="true">#</a> ISO-TP tools</h3>',15),o=(0,n.Uk)("The Linux kernel "),d={href:"https://github.com/hartkopp/can-isotp",target:"_blank",rel:"noopener noreferrer"},c=(0,n.Uk)("supports CAN ISO-TP"),i=(0,n.Uk)(", which is used as the transport protocol for ThingSet."),r=(0,n.uE)('<p>Assuming a device with CAN address 1 is connected to the bus, the following command sets up an ISO-TP channel for messages from the device to the host computer (CAN address 0):</p><div class="language-text ext-text"><pre class="language-text"><code>isotprecv -l -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p>In order to request the node ID in binary mode from the device with address 1, run the following command:</p><div class="language-text ext-text"><pre class="language-text"><code>echo &quot;01 18 1D&quot; | isotpsend -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p>The same for text mode:</p><div class="language-text ext-text"><pre class="language-text"><code>echo -n &quot;?cNodeId&quot; | hexdump -v -e &#39;/1 &quot;%02X &quot;&#39; | isotpsend -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p><code>isotprecv</code> only prints the hex values of the received data. The ASCII payload can be monitored using:</p><div class="language-text ext-text"><pre class="language-text"><code>isotpsniffer -tA -f 2 -d 0x18000100 -s 0x18000001 can0\n</code></pre></div>',8),l={render:function(e,t){const a=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[s,(0,n._)("p",null,[o,(0,n._)("a",d,[c,(0,n.Wm)(a)]),i]),r],64)}}}}]);
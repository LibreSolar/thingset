"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5191],{9492:(e,t,a)=>{a.r(t),a.d(t,{data:()=>i});const i={key:"v-fbd9991e",path:"/spec/v0.5/mapping_mqtt.html",title:"MQTT",lang:"en",frontmatter:{title:"MQTT"},excerpt:"",headers:[{level:2,title:"General thoughts",slug:"general-thoughts",children:[]},{level:2,title:"Statements",slug:"statements",children:[{level:3,title:"Device to application",slug:"device-to-application",children:[]},{level:3,title:"Application to device",slug:"application-to-device",children:[]}]},{level:2,title:"Request / response",slug:"request-response",children:[]},{level:2,title:"Data Processing",slug:"data-processing",children:[{level:3,title:"Device to Broker",slug:"device-to-broker",children:[]},{level:3,title:"Broker to Device",slug:"broker-to-device",children:[]},{level:3,title:"Broker to Device (requests)",slug:"broker-to-device-requests",children:[]}]},{level:2,title:"Special topic for connectivity status",slug:"special-topic-for-connectivity-status",children:[]},{level:2,title:"Provider Incompatibilities",slug:"provider-incompatibilities",children:[]},{level:2,title:"References",slug:"references",children:[]}],filePathRelative:"spec/v0.5/mapping_mqtt.md",git:{updatedTime:170759614e4}}},6648:(e,t,a)=>{a.r(t),a.d(t,{default:()=>A});var i=a(6252);const n=(0,i.uE)('<h1 id="thingset-to-mqtt-mapping" tabindex="-1"><a class="header-anchor" href="#thingset-to-mqtt-mapping" aria-hidden="true">#</a> ThingSet to MQTT mapping</h1><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>The MQTT mapping is still work-in-progress and may change in the future.</p></div><p>This chapter specifies a topic layout that supports the publish/subscribe as well as the request/response feature of ThingSet.</p><p>Typically, a gateway would be used to translate the messages between the node (connected via CAN or serial) and the MQTT broker.</p><h2 id="general-thoughts" tabindex="-1"><a class="header-anchor" href="#general-thoughts" aria-hidden="true">#</a> General thoughts</h2><p>The basic MQTT topic layout for ThingSet follows the below structure:</p><pre><code>{message-type}/{node-id}/{details}\n</code></pre><p>The first part of the topic indicates the message type (request, response or statement) and mode (text or binary).</p><p>The second part contains the node ID, followed by further details depending on the message type.</p><p>This layout allows to easily grant access rights for individual nodes e.g. with following wild card:</p><pre><code>+/{node-id}/#\n</code></pre><p>A Gateway that translates MQTT messages for multiple devices (e.g. connected via CAN) has to subscribe to the downlink message topics for each individual connected node.</p>',12),r={class:"custom-container tip"},o=(0,i._)("p",{class:"custom-container-title"},"Background information",-1),s=(0,i.Uk)("Many MQTT services for IoT don't behave like actual MQTT brokers, but use MQTT only as an API (AWS IoT, Azure IoT, "),d={href:"https://www.eclipse.org/hono/docs/user-guide/mqtt-adapter/",target:"_blank",rel:"noopener noreferrer"},l=(0,i.Uk)("Eclipse Hono"),c=(0,i.Uk)(", ThingsBoard). This allows to omit the device ID in the MQTT topic and determine the device based on the MQTT Client ID."),h=(0,i._)("p",null,"ThingSet supports standard MQTT brokers and thus stores the device ID in the topic. The device ID is also necessary for Gateways.",-1),p=(0,i._)("p",null,"A user name is not part of the topic, as device claiming is usually part of the cloud backend and user information may not be stored in the device.",-1),g=(0,i.uE)('<h2 id="statements" tabindex="-1"><a class="header-anchor" href="#statements" aria-hidden="true">#</a> Statements</h2><h3 id="device-to-application" tabindex="-1"><a class="header-anchor" href="#device-to-application" aria-hidden="true">#</a> Device to application</h3><p>Messages in text mode are published to the <code>report</code> path and the payload format must be the valid JSON data extracted from a ThingSet statement.</p><p><strong>JSON name:value map, QoS 0/1</strong></p><pre><code>report/{node-id}/{group}\n</code></pre><p>Messages can also be published directly in the binary format to the <code>r</code> path if the device does not support the text mode.</p><p>Binary messages can either be published as a map or with IDs and values in a separate topic.</p><p><strong>CBOR id:value map, QoS 0/1</strong></p><pre><code>r/{node-id}/m/{group-id}\n</code></pre><p><strong>CBOR ids, retained flag, QoS 1</strong></p><pre><code>r/{node-id}/i/{group-id}\n</code></pre><p><strong>CBOR values, QoS 0</strong></p><pre><code>r/{node-id}/v/{group-id}\n</code></pre><p>The text mode is the preferred way for MQTT communication if supported by the device or gateway.</p><p>A cloud service might subscribe to the CBOR topics and convert them into the JSON topic automatically so that they can be further processed by other services.</p><p>The link to extended device data information will be published to a special topic:</p><pre><code>report/{node-id}/cMetadataURL\n</code></pre><p>If the binary mode is used with separated IDs and values, the IDs should be published with QoS 1 and the retained flag in order to make sure they are always available and matching the values that are sent to the <code>/v/</code> topic.</p><p>If possible, static data like firmware version should only be published once after startup (e.g. as part of a dedicated subset for static data) and may use the retained flag aswell.</p><p>A gateway does not know which messages should have the retained flag, so the retained flags may only be suitable for cloud to device communication.</p><h3 id="application-to-device" tabindex="-1"><a class="header-anchor" href="#application-to-device" aria-hidden="true">#</a> Application to device</h3><p><strong>JSON name:value map</strong></p><pre><code>desire/{node-id}/{group-name}\n</code></pre><p><strong>CBOR id:value map</strong></p><pre><code>d/{node-id}/m/{group-id}\n</code></pre><p><strong>CBOR ids</strong></p><pre><code>d/{node-id}/i/{group-id}\n</code></pre><p><strong>CBOR values</strong></p><pre><code>d/{node-id}/v/{group-id}\n</code></pre><h2 id="request-response" tabindex="-1"><a class="header-anchor" href="#request-response" aria-hidden="true">#</a> Request / response</h2><p>For the request / response messaging mode the response has to be matched with the request. For this reason, the request is stored in a topic with an appended request ID chosen by the requesting device. The response will be stored in a topic containing the same ID.</p><p><strong>Requests (JSON or CBOR)</strong></p><pre><code>req/{node-id}/{req-id}\n</code></pre><p><strong>Response (JSON or CBOR, same as request)</strong></p><pre><code>res/{node-id}/{req-id}\n</code></pre><p>The above topics contain the entire ThingSet request or response. Hence, both binary or text mode can be used with the same topic.</p><h2 id="data-processing" tabindex="-1"><a class="header-anchor" href="#data-processing" aria-hidden="true">#</a> Data Processing</h2><p>The following diagrams explain the data flow between a device and an MQTT broker.</p><p>In case of LoRaWAN or CAN where the binary mode with IDs is used, an agent may be installed which subscribes to the binary messages and translates them to the JSON messages which are later on consumed by a higher-level application.</p><p>This translation can also be done on a local gateway.</p><p>The mapping of IDs and names can either be retrieved from the device (e.g. via request/response for a device connected via CAN) or it can be stored in a <code>.json</code> file on a server which contains extended information. The detailed specification of this file is still work in progress.</p><h3 id="device-to-broker" tabindex="-1"><a class="header-anchor" href="#device-to-broker" aria-hidden="true">#</a> Device to Broker</h3><h4 id="mqtt-direct-low-bandwidth-with-agent" tabindex="-1"><a class="header-anchor" href="#mqtt-direct-low-bandwidth-with-agent" aria-hidden="true">#</a> MQTT direct (low bandwidth, with agent)</h4><ul><li>e.g. 2G with global SIM card and very low data rate</li><li>ID mapping by data agent</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev       MQTT:bin     Agent       MQTT:txt     Broker\n |                       |                        |\n |                       |                        |\n |     ids (QoS 1)       |                        |\n | --------------------&gt; |                        |\n |    values (QoS 0)     |                        |\n | --------------------&gt; |    objects (QoS 0)     |\n |                       | ---------------------&gt; |\n |                       |                        |\n |         ...           |                        |\n |                       |                        |\n |    values (QoS 0)     |                        |\n | --------------------&gt; |    objects (QoS 0)     |\n |                       | ---------------------&gt; |\n</code></pre></div><h4 id="mqtt-direct-sufficient-bandwidth" tabindex="-1"><a class="header-anchor" href="#mqtt-direct-sufficient-bandwidth" aria-hidden="true">#</a> MQTT direct (sufficient bandwidth)</h4><ul><li>e.g. LTE with local SIM card</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev       MQTT:txt     Broker\n |                        |\n |    objects (QoS 0)     |\n | ---------------------&gt; |\n</code></pre></div><h4 id="serial" tabindex="-1"><a class="header-anchor" href="#serial" aria-hidden="true">#</a> Serial</h4><div class="language-text ext-text"><pre class="language-text"><code>Dev    UART:txt    GW    MQTT:txt   Broker\n |                 |                  |\n |     objects     |                  |\n | --------------&gt; |      objects     |\n |                 | ---------------&gt; |\n</code></pre></div><h4 id="can-smart-gateway" tabindex="-1"><a class="header-anchor" href="#can-smart-gateway" aria-hidden="true">#</a> CAN (smart gateway)</h4><ul><li>ID mapping and translation between binary and text mode on gateway</li><li>Preferred way</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev     CAN:bin       GW       MQTT:txt       Broker\n |                    |                         |\n |      values        |                         |\n | -----------------&gt; |                         |\n |   req/resp names   |                         |\n | &lt;----------------&gt; |    objects (QoS 0)      |\n |                    | ----------------------&gt; |\n |         ...        |                         |\n |                    |                         |\n |      values        |                         |\n | -----------------&gt; |    objects (QoS 0)      |\n |                    | ----------------------&gt; |\n</code></pre></div><h4 id="can-with-data-agent" tabindex="-1"><a class="header-anchor" href="#can-with-data-agent" aria-hidden="true">#</a> CAN (with data agent)</h4><ul><li>ID mapping by data agent</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev     CAN:bin      GW       MQTT:bin       Agent       MQTT:txt     Broker\n |                   |                         |                        |\n |      values       |                         |                        |\n | ----------------&gt; |                         |                        |\n |   req/resp ids    |                         |                        |\n | &lt;---------------&gt; |     ids (QoS 1)         |                        |\n |                   | ----------------------&gt; |                        |\n |                   |    values (QoS 0)       |                        |\n |                   | ----------------------&gt; |    objects (QoS 0)     |\n |                   |                         | ---------------------&gt; |\n |        ...        |                         |                        |\n |                   |                         |                        |\n |      values       |                         |                        |\n | ----------------&gt; |    values (QoS 0)       |                        |\n |                   | ----------------------&gt; |    objects (QoS 0)     |\n |                   |                         | ---------------------&gt; |\n</code></pre></div><h4 id="lorawan-smart-gateway" tabindex="-1"><a class="header-anchor" href="#lorawan-smart-gateway" aria-hidden="true">#</a> LoRaWAN (smart gateway)</h4><ul><li>ID mapping on gateway</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev   LoRaWAN:bin      GW       MQTT:txt      Broker\n |                     |                        |\n |     ids (ACK-ed)    |                        |\n | ------------------&gt; |                        |\n |       values        |                        |\n | ------------------&gt; |    objects (QoS 0)     |\n |                     | ---------------------&gt; |\n |        ...          |                        |\n |                     |                        |\n |       values        |                        |\n | ------------------&gt; |    objects (QoS 0)     |\n |                     | ---------------------&gt; |\n</code></pre></div><h4 id="lorawan-with-data-agent" tabindex="-1"><a class="header-anchor" href="#lorawan-with-data-agent" aria-hidden="true">#</a> LoRaWAN (with data agent)</h4><ul><li>Simple forwarding of messages by gateway</li><li>ID mapping by data agent or statically via TTN payload formatter</li><li>Probably preferred way in order to be able to use standard TTN gateways</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev   LoRaWAN:bin      GW       MQTT:bin     Agent       MQTT:txt     Broker\n |                     |                       |                        |\n |     ids (ACK-ed)    |                       |                        |\n | ------------------&gt; |     ids (QoS 1)       |                        |\n |       values        | --------------------&gt; |                        |\n | ------------------&gt; |    values (QoS 0)     |                        |\n |                     | --------------------&gt; |    objects (QoS 0)     |\n |                     |                       | ---------------------&gt; |\n |        ...          |                       |                        |\n |                     |                       |                        |\n |       values        |                       |                        |\n | ------------------&gt; |    values (QoS 0)     |                        |\n |                     | --------------------&gt; |    objects (QoS 0)     |\n |                     |                       | ---------------------&gt; |\n</code></pre></div><h3 id="broker-to-device" tabindex="-1"><a class="header-anchor" href="#broker-to-device" aria-hidden="true">#</a> Broker to Device</h3><h4 id="serial-1" tabindex="-1"><a class="header-anchor" href="#serial-1" aria-hidden="true">#</a> Serial</h4><div class="language-text ext-text"><pre class="language-text"><code>Dev    UART:txt     GW   MQTT:txt    Broker\n |                  |                  |\n |                  |      objects     |\n |      objects     | &lt;--------------- |\n | &lt;--------------- |                  |\n</code></pre></div><h4 id="can-direct" tabindex="-1"><a class="header-anchor" href="#can-direct" aria-hidden="true">#</a> CAN (direct)</h4><ul><li>No mapping of IDs needed, as incoming statements are sent via ISO-TP and can have almost arbitrary length.</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev     CAN:txt      GW       MQTT:txt       Broker\n |                   |                         |\n |                   |      objects (QoS 0)    |\n |      objects      | &lt;---------------------- |\n | &lt;---------------- |                         |\n</code></pre></div><h4 id="lorawan-direct" tabindex="-1"><a class="header-anchor" href="#lorawan-direct" aria-hidden="true">#</a> LoRaWAN (direct)</h4><ul><li>ID mapping on gateway</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev   LoRaWAN:bin      GW       MQTT:txt      Broker\n |                     |                        |\n |    ids (ACK-ed)     |                        |\n | ------------------&gt; |                        |\n |                     |                        |\n |        ...          |                        |\n |                     |                        |\n |                     |     objects (QoS 0)    |\n |       values        | &lt;--------------------- |\n | &lt;------------------ |                        |\n</code></pre></div><h4 id="lorawan-with-data-agent-1" tabindex="-1"><a class="header-anchor" href="#lorawan-with-data-agent-1" aria-hidden="true">#</a> LoRaWAN (with data agent)</h4><ul><li>Simple forwarding of messages by gateway</li><li>ID mapping by data agent or statically via TTN payload formatter</li><li>Probably preferred way in order to be able to use standard TTN gateways</li></ul><div class="language-text ext-text"><pre class="language-text"><code>Dev   LoRaWAN:bin      GW       MQTT:bin     Agent       MQTT:txt     Broker\n |                     |                       |                        |\n |    ids (ACK-ed)     |                       |                        |\n | ------------------&gt; |     ids (QoS 1)       |                        |\n |       values        | --------------------&gt; |                        |\n | ------------------&gt; |    values (QoS 0)     |                        |\n |                     | --------------------&gt; |    objects (QoS 0)     |\n |                     |                       | ---------------------&gt; |\n |        ...          |                       |                        |\n |                     |                       |                        |\n |       values        |                       |                        |\n | ------------------&gt; |    values (QoS 0)     |                        |\n |                     | --------------------&gt; |    objects (QoS 0)     |\n |                     |                       | ---------------------&gt; |\n</code></pre></div><h3 id="broker-to-device-requests" tabindex="-1"><a class="header-anchor" href="#broker-to-device-requests" aria-hidden="true">#</a> Broker to Device (requests)</h3><p>ToDo</p><h2 id="special-topic-for-connectivity-status" tabindex="-1"><a class="header-anchor" href="#special-topic-for-connectivity-status" aria-hidden="true">#</a> Special topic for connectivity status</h2>',77),u={class:"custom-container warning"},v=(0,i._)("p",{class:"custom-container-title"},"WARNING",-1),b=(0,i._)("p",null,"This is a first idea for an approach to store connectivity information. Expect changes in the future.",-1),m=(0,i.Uk)("See also "),f={href:"http://www.steves-internet-guide.com/checking-active-mqtt-client-connections/",target:"_blank",rel:"noopener noreferrer"},T=(0,i.Uk)("here"),w=(0,i.Uk)(" for further ideas."),x=(0,i.uE)('<p>The following topic is used to store device connectivity status:</p><pre><code>report/{node-id}/$conn\n</code></pre><ol><li>Client connects and sends 1 to above topic.</li><li>Client sends last will and testament (LWT) with content 0 for that topic.</li><li>On normal disconnect, client sends 0 before disconnecting.</li></ol><p>All messages should be retained.</p><p><strong>Idea:</strong> Use this topic to tell that client is intermittent / async by design (e.g. in case of LoRaWAN).</p><h2 id="provider-incompatibilities" tabindex="-1"><a class="header-anchor" href="#provider-incompatibilities" aria-hidden="true">#</a> Provider Incompatibilities</h2><p>AWS is not MQTT compliant:</p><p>https://www.hivemq.com/blog/hivemq-cloud-vs-aws-iot/</p><p>Handling of retained messages is wrong. According to MQTT standard, subscribing to a retained topic via wild-cards would deliver the mesage. In AWS it doesn&#39;t.</p><p>https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html#mqtt-retain</p><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references" aria-hidden="true">#</a> References</h2>',11),y=(0,i.Uk)("[1] "),Q={href:"https://d1.awsstatic.com/whitepapers/Designing_MQTT_Topics_for_AWS_IoT_Core.pdf",target:"_blank",rel:"noopener noreferrer"},S=(0,i.Uk)("Designing MQTT Topics for AWS IoT Core"),k=(0,i._)("p",null,"[2] https://pi3g.com/2019/05/29/mqtt-topic-tree-design-best-practices-tips-examples/",-1),A={render:function(e,t){const a=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[n,(0,i._)("div",r,[o,(0,i._)("p",null,[s,(0,i._)("a",d,[l,(0,i.Wm)(a)]),c]),h,p]),g,(0,i._)("div",u,[v,b,(0,i._)("p",null,[m,(0,i._)("a",f,[T,(0,i.Wm)(a)]),w])]),x,(0,i._)("p",null,[y,(0,i._)("a",Q,[S,(0,i.Wm)(a)])]),k],64)}}}}]);
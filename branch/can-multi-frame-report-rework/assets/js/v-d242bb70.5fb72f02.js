"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6610],{2050:(e,a,t)=>{t.r(a),t.d(a,{data:()=>n});const n={key:"v-d242bb70",path:"/spec/v0.6/annex/b_tools.html",title:"Annex B: Tools",lang:"en",frontmatter:{},excerpt:"",headers:[{level:2,title:"Serial",slug:"serial",children:[{level:3,title:"Hardware",slug:"hardware",children:[]},{level:3,title:"Software",slug:"software",children:[]}]},{level:2,title:"CAN under Linux",slug:"can-under-linux",children:[{level:3,title:"CAN interface setup",slug:"can-interface-setup",children:[]},{level:3,title:"ISO-TP tools",slug:"iso-tp-tools",children:[]}]}],filePathRelative:"spec/v0.6/annex/b_tools.md",git:{updatedTime:1709745994e3}}},479:(e,a,t)=>{t.r(a),t.d(a,{default:()=>x});var n=t(6252);const r=(0,n.uE)('<h1 id="annex-b-tools" tabindex="-1"><a class="header-anchor" href="#annex-b-tools" aria-hidden="true">#</a> Annex B: Tools</h1><h2 id="serial" tabindex="-1"><a class="header-anchor" href="#serial" aria-hidden="true">#</a> Serial</h2><h3 id="hardware" tabindex="-1"><a class="header-anchor" href="#hardware" aria-hidden="true">#</a> Hardware</h3><p>Any USB to UART converter can be used, e.g. the one included in STM32 Nucleo boards.</p><h3 id="software" tabindex="-1"><a class="header-anchor" href="#software" aria-hidden="true">#</a> Software</h3>',5),s={href:"http://cutecom.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},o=(0,n.Uk)("CuteCom"),d=(0,n.Uk)(" for Linux and Mac OS has a built-in command history, which makes it easy to interact manually with devices via ThingSet."),i=(0,n.uE)('<h2 id="can-under-linux" tabindex="-1"><a class="header-anchor" href="#can-under-linux" aria-hidden="true">#</a> CAN under Linux</h2><h3 id="can-interface-setup" tabindex="-1"><a class="header-anchor" href="#can-interface-setup" aria-hidden="true">#</a> CAN interface setup</h3><p>There are different USB to CAN dongles available on the market, which usually support communicating with the Linux Kernel via a serial interface.</p><p>The following command creates a <code>can0</code> interface from a dongle attached to <code>/dev/ttyUSB0</code>:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo slcan_attach /dev/ttyUSB0 -w\n</code></pre></div><p>Afterwards, the interface has to be configured and started. Here we are setting the bit rate to 500 kbit/s:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link set can0 type can bitrate 500000 restart-ms 500\nsudo ip link set can0 up\n</code></pre></div><p>If you want to see also your own messages, loopback mode has to be enabled before setting the interface up:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link set can0 type can loopback on\n</code></pre></div><p>Now, <code>candump</code> can be used to read all data available on the bus:</p><div class="language-text ext-text"><pre class="language-text"><code>candump can0\n</code></pre></div><p>Instead of an actual CAN device, also a virtual CAN device can be used on the Linux host:</p><div class="language-text ext-text"><pre class="language-text"><code>sudo ip link add dev vcan0 type vcan\nsudo ip link set up vcan0\n</code></pre></div><h3 id="iso-tp-tools" tabindex="-1"><a class="header-anchor" href="#iso-tp-tools" aria-hidden="true">#</a> ISO-TP tools</h3>',14),l=(0,n.Uk)("The Linux kernel "),c={href:"https://github.com/hartkopp/can-isotp",target:"_blank",rel:"noopener noreferrer"},u=(0,n.Uk)("supports CAN ISO-TP"),h=(0,n.Uk)(", which is used as the transport protocol for ThingSet."),p=(0,n.uE)('<p>Assuming a device with CAN address 1 is connected to the bus, the following command sets up an ISO-TP channel for messages from the device to the host computer (CAN address 0):</p><div class="language-text ext-text"><pre class="language-text"><code>isotprecv -l -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p>In order to request the node ID in binary mode from the device with address 1, run the following command:</p><div class="language-text ext-text"><pre class="language-text"><code>echo &quot;01 18 1D&quot; | isotpsend -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p>The same for text mode:</p><div class="language-text ext-text"><pre class="language-text"><code>echo -n &quot;?pNodeID&quot; | hexdump -v -e &#39;/1 &quot;%02X &quot;&#39; | isotpsend -s 0x18000100 -d 0x18000001 can0\n</code></pre></div><p><code>isotprecv</code> only prints the hex values of the received data. The ASCII payload can be monitored using:</p><div class="language-text ext-text"><pre class="language-text"><code>isotpsniffer -tA -f 2 -d 0x18000100 -s 0x18000001 can0\n</code></pre></div>',8),x={render:function(e,a){const t=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[r,(0,n._)("p",null,[(0,n._)("a",s,[o,(0,n.Wm)(t)]),d]),i,(0,n._)("p",null,[l,(0,n._)("a",c,[u,(0,n.Wm)(t)]),h]),p],64)}}}}]);